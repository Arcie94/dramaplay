---
interface Props {
  videoUrl: string;
  coverUrl: string;
  title: string;
  nextUrl?: string;
  prevUrl?: string;
  id?: string; // Book ID for My List
  dramaTitle?: string; // Clean Title for My List
  totalEpisodes?: any; // Total Episodes for My List
  isHorizontal?: boolean; // For Movies/Landscape content
  isIframe?: boolean; // For Embeds
}

const {
  videoUrl,
  coverUrl,
  title,
  nextUrl,
  prevUrl,
  id,
  dramaTitle,
  totalEpisodes,
  isHorizontal = false,
  isIframe = false,
} = Astro.props;
---

<div
  class="relative w-full h-[100dvh] bg-black overflow-hidden flex justify-center items-center"
>
  <!-- Desktop Backdrop (Universal) -->
  <div class="absolute inset-0 z-0">
    <img
      src={coverUrl}
      alt="Background"
      class="w-full h-full object-cover blur-3xl opacity-50 scale-110"
    />
    <div class="absolute inset-0 bg-black/60"></div>
  </div>

  <!-- Main Player Container -->
  <!-- 
        Logic: 
        - Vertical: aspect-[9/16] (Shorts style)
        - Horizontal: w-full max-w-5xl aspect-video (Movie style)
    -->
  <div
    id="video-container"
    class={`relative z-10 w-full max-h-[100dvh] bg-black overflow-hidden flex items-center justify-center shadow-2xl ${
      isHorizontal
        ? "aspect-video max-w-6xl h-auto"
        : "aspect-[9/16] h-full w-auto max-w-full"
    }`}
  >
    {
      isIframe ? (
        /* IFRAME MODE (No Custom Controls) */
        <iframe
          src={videoUrl}
          class="w-full h-full"
          frameborder="0"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
          allowfullscreen
        />
      ) : (
        /* VIDEO MODE (Custom Controls) */
        <>
          <video
            id="main-video"
            src={videoUrl}
            poster={coverUrl}
            class={`absolute top-0 left-0 w-full h-full ${isHorizontal ? "object-contain" : "object-cover"}`}
            playsinline
            loop={false}
            autoplay
            webkit-playsinline
            data-next-url={nextUrl}
            data-prev-url={prevUrl}
            data-book-id={id}
            data-drama-title={dramaTitle}
            data-total-episodes={totalEpisodes}
            data-cover-url={coverUrl}
          />

          {/* Overlay Gradient (Top) */}
          <div class="absolute top-0 left-0 w-full h-32 bg-gradient-to-b from-black/80 to-transparent pointer-events-none z-10" />

          {/* Top Right Group (Volume/Fullscreen) */}
          <div
            class="absolute top-4 right-4 z-50 flex flex-col gap-3 transition-opacity duration-500"
            id="top-right-controls"
          >
            {/* Volume Control Group */}
            <div
              id="volume-control"
              class="flex flex-col items-center bg-black/50 hover:bg-black/70 backdrop-blur-md rounded-full p-2 transition-all duration-300 group"
            >
              <div class="h-0 w-8 overflow-hidden group-hover:h-24 transition-all duration-300 ease-out flex items-center justify-center">
                <input
                  type="range"
                  id="volume-slider"
                  min="0"
                  max="1"
                  step="0.1"
                  value="1"
                  class="w-20 h-1 bg-white/30 rounded-lg appearance-none cursor-pointer -rotate-90 origin-center accent-red-600 hover:accent-red-500"
                />
              </div>
              <button
                id="mute-btn"
                class="p-1 text-white active:scale-90 transition-transform"
              >
                <svg
                  id="icon-muted"
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke-width="1.5"
                  stroke="currentColor"
                  class="w-6 h-6 hidden"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    d="M17.25 9.75L19.5 12m0 0l2.25 2.25M19.5 12l2.25-2.25M19.5 12l-2.25 2.25m-10.5-6l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75z"
                  />
                </svg>
                <svg
                  id="icon-unmuted"
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke-width="1.5"
                  stroke="currentColor"
                  class="w-6 h-6"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    d="M19.114 5.636a9 9 0 010 12.728M16.463 8.288a5.25 5.25 0 010 7.424M6.75 8.25l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75z"
                  />
                </svg>
              </button>
            </div>

            <button
              id="fullscreen-btn"
              class="p-3 bg-black/50 hover:bg-black/70 backdrop-blur-md rounded-full text-white active:scale-90 transition-transform flex items-center justify-center"
            >
              <svg
                id="icon-maximize"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
                stroke-width="1.5"
                stroke="currentColor"
                class="w-6 h-6"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15"
                />
              </svg>
              <svg
                id="icon-minimize"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
                stroke-width="1.5"
                stroke="currentColor"
                class="w-6 h-6 hidden"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5M15 15l5.25 5.25"
                />
              </svg>
            </button>
          </div>

          {/* Overlay Gradient (Bottom) */}
          <div class="absolute bottom-0 left-0 w-full h-64 bg-gradient-to-t from-black/90 via-black/40 to-transparent pointer-events-none z-10" />

          {/* Play/Pause Overlay */}
          <div
            id="play-overlay"
            class="absolute inset-0 z-20 cursor-pointer bg-transparent"
          />
          <div
            id="play-icon"
            class="absolute inset-0 z-30 flex items-center justify-center pointer-events-none opacity-0 transition-opacity"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              fill="white"
              viewBox="0 0 24 24"
              class="w-20 h-20 drop-shadow-lg"
            >
              <path d="M8 5v14l11-7z" />
            </svg>
          </div>

          {/* Bottom Info & Controls */}
          <div
            id="bottom-controls"
            class="absolute bottom-0 left-0 w-full p-6 z-50 flex flex-col gap-4 transition-opacity duration-500"
          >
            <h1 class="text-xl font-bold text-white drop-shadow-md">{title}</h1>

            {/* Progress Bar */}
            <div
              id="progress-container"
              class="w-full py-3 cursor-pointer group flex items-center touch-none"
            >
              <div class="w-full h-1 bg-white/30 rounded-full overflow-hidden group-hover:h-1.5 transition-all duration-200 pointer-events-none">
                <div id="progress-bar" class="relative h-full bg-red-600 w-0">
                  <div class="absolute right-0 top-1/2 -translate-y-1/2 translate-x-1/2 w-3 h-3 bg-red-600 rounded-full shadow-md scale-0 group-hover:scale-110 transition-transform duration-200" />
                </div>
              </div>
            </div>

            {/* Action Buttons */}
            <div class="flex items-center justify-between text-white">
              <div class="flex gap-4">
                <button
                  id="mylist-btn"
                  class="flex flex-col items-center gap-1 group"
                >
                  <svg
                    id="icon-add"
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke-width="1.5"
                    stroke="currentColor"
                    class="w-8 h-8 group-active:scale-90 transition-transform"
                  >
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      d="M17.593 3.322c1.1.128 1.907 1.077 1.907 2.185V21L12 17.25 4.5 21V5.507c0-1.108.806-2.057 1.907-2.185a48.507 48.507 0 0111.186 0z"
                    />
                  </svg>
                  <svg
                    id="icon-check"
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 24 24"
                    fill="currentColor"
                    class="w-8 h-8 text-red-500 hidden group-active:scale-90 transition-transform"
                  >
                    <path
                      fill-rule="evenodd"
                      d="M6.32 2.577a49.255 49.255 0 0111.36 0c1.497.174 2.57 1.46 2.57 2.93V21a.75.75 0 01-1.085.67L12 18.089l-7.165 3.583A.75.75 0 013.75 21V5.507c0-1.47 1.073-2.756 2.57-2.93z"
                      clip-rule="evenodd"
                    />
                  </svg>
                  <span id="mylist-text" class="text-xs">
                    My List
                  </span>
                </button>
                <button
                  id="comment-btn"
                  class="flex flex-col items-center gap-1 active:scale-95 transition-transform"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 24 24"
                    fill="currentColor"
                    class="w-8 h-8"
                  >
                    <path
                      fill-rule="evenodd"
                      d="M4.804 21.644A6.707 6.707 0 006 21.75a6.721 6.721 0 003.583-1.029c.774.182 1.584.279 2.417.279 5.322 0 9.75-3.97 9.75-9 0-5.03-4.428-9-9.75-9s-9.75 3.97-9.75 9c0 2.409 1.025 4.608 2.75 6.257a1.606 1.606 0 01.32.964v2.423z"
                      clip-rule="evenodd"
                    />
                  </svg>
                  <span class="text-xs">Comment</span>
                </button>
              </div>

              <div class="flex gap-2">
                {prevUrl && (
                  <a
                    href={prevUrl}
                    class="px-4 py-2 bg-white/20 rounded-full backdrop-blur-sm text-sm font-semibold"
                  >
                    Prev
                  </a>
                )}
                {nextUrl && (
                  <a
                    id="next-btn"
                    href={nextUrl}
                    class="px-4 py-2 bg-red-600 rounded-full text-white text-sm font-semibold shadow-red-900/50 shadow-lg"
                  >
                    Next Ep
                  </a>
                )}
              </div>
            </div>
          </div>
        </>
      )
    }

    {/* Always show Top Left Back Button */}
    <div
      id="top-left-controls"
      class="absolute top-4 left-4 z-50 transition-opacity duration-500"
    >
      <a
        href={`/detail/${id}`}
        class="p-3 bg-white/10 backdrop-blur-md rounded-full text-white active:scale-90 transition-transform block"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          stroke-width="2"
          stroke="currentColor"
          class="w-6 h-6"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            d="M15.75 19.5L8.25 12l7.5-7.5"></path>
        </svg>
      </a>
    </div>
  </div>

  <!-- Comments Bottom Sheet -->
  <div
    id="comments-sheet"
    class="absolute inset-x-0 bottom-0 z-50 bg-[#1a1a1a] rounded-t-2xl transform translate-y-full transition-transform duration-300 ease-out h-[70vh] flex flex-col shadow-2xl border-t border-white/10"
  >
    <!-- Handle Bar -->
    <div class="w-full flex justify-center pt-3 pb-1" id="comments-handle">
      <div class="w-12 h-1.5 bg-zinc-700 rounded-full"></div>
    </div>

    <!-- Header -->
    <div
      class="px-4 py-2 flex items-center justify-between border-b border-white/5"
    >
      <h3 class="text-white font-bold text-lg">
        Comments <span
          id="comment-count"
          class="text-zinc-500 text-sm font-normal">(0)</span
        >
      </h3>
      <button id="close-comments" class="p-2 text-zinc-400 hover:text-white">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          stroke-width="2"
          stroke="currentColor"
          class="w-6 h-6"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
    </div>

    <!-- Comments List -->
    <div
      id="comments-list"
      class="flex-1 overflow-y-auto p-4 space-y-4 no-scrollbar"
    >
      <!-- Dynamic Content -->
    </div>

    <!-- Input Area -->
    <div class="p-4 border-t border-white/10 bg-[#1a1a1a] pb-safe">
      <form id="comment-form" class="flex gap-3">
        <input
          type="text"
          id="comment-input"
          placeholder="Add a comment..."
          class="flex-1 bg-zinc-800 text-white rounded-full px-4 py-2.5 text-sm focus:outline-none focus:ring-1 focus:ring-red-600 border border-transparent placeholder-zinc-500"
        />
        <button
          type="submit"
          class="bg-red-600 text-white p-2.5 rounded-full hover:bg-red-700 active:scale-95 transition-transform disabled:opacity-50 disabled:cursor-not-allowed"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            fill="currentColor"
            class="w-5 h-5"
          >
            <path
              d="M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.519 60.519 0 0018.445-8.986.75.75 0 000-1.218A60.517 60.517 0 003.478 2.405z"
            ></path>
          </svg>
        </button>
      </form>
    </div>
  </div>
  <!-- Comments Overlay Backdrop -->
  <div
    id="comments-backdrop"
    class="absolute inset-0 z-40 bg-black/50 opacity-0 pointer-events-none transition-opacity duration-300 backdrop-blur-sm"
  >
  </div>
</div>

<!-- Delete Confirmation Modal (Professional Style) -->
<div
  id="delete-confirm-modal"
  class="hidden absolute inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm animate-in fade-in duration-200"
>
  <div
    class="bg-zinc-900 border border-zinc-700 p-6 rounded-2xl w-[90%] max-w-sm text-center shadow-xl transform scale-100"
  >
    <h3 class="text-white font-bold text-lg mb-2">Delete Comment?</h3>
    <p class="text-zinc-400 text-sm mb-6">
      Are you sure you want to delete this comment? This action cannot be
      undone.
    </p>
    <div class="grid grid-cols-2 gap-3">
      <button
        id="btn-cancel-delete"
        class="px-4 py-3 rounded-xl bg-zinc-800 text-white font-semibold hover:bg-zinc-700 transition-colors"
        >Cancel</button
      >
      <button
        id="btn-confirm-delete"
        class="px-4 py-3 rounded-xl bg-red-600 text-white font-semibold hover:bg-red-700 transition-colors"
        >Delete</button
      >
    </div>
  </div>
</div>

<!-- Custom Toast -->
<div
  id="custom-toast"
  class="absolute top-20 left-1/2 -translate-x-1/2 z-[60] px-4 py-2 bg-zinc-800 text-white text-sm font-medium rounded-full shadow-lg border border-zinc-700 opacity-0 pointer-events-none transition-all duration-300 transform translate-y-[-10px]"
>
  <span id="toast-message">Notification</span>
</div>

<style>
  .pb-safe {
    padding-bottom: max(env(safe-area-inset-bottom), 16px);
  }
</style>

<script>
  const video = document.getElementById("main-video") as HTMLVideoElement;
  const container = document.getElementById("video-container");
  const playOverlay = document.getElementById("play-overlay");
  const playIcon = document.getElementById("play-icon");
  const progressContainer = document.getElementById("progress-container");
  const progressBar = document.getElementById("progress-bar");
  const muteBtn = document.getElementById("mute-btn");
  const volumeSlider = document.getElementById(
    "volume-slider"
  ) as HTMLInputElement;
  const volumeControl = document.getElementById("volume-control"); // Wrapper for auto-hide
  const iconMuted = document.getElementById("icon-muted");
  const iconUnmuted = document.getElementById("icon-unmuted");
  const bottomControls = document.getElementById("bottom-controls");
  const topLeftControls = document.getElementById("top-left-controls");

  // Comment Elements
  const commentsSheet = document.getElementById("comments-sheet");
  const commentsBackdrop = document.getElementById("comments-backdrop");
  const commentCount = document.getElementById("comment-count");
  const commentsList = document.getElementById("comments-list");
  const commentForm = document.getElementById("comment-form");
  const commentInput = document.getElementById(
    "comment-input"
  ) as HTMLInputElement;

  // Modal Elements
  const deleteModal = document.getElementById("delete-confirm-modal");
  const btnCancelDelete = document.getElementById("btn-cancel-delete");
  const btnConfirmDelete = document.getElementById("btn-confirm-delete");
  let pendingDeleteIndex = -1;

  console.log("Video Player Script Initialized");

  if (video) {
    // --- History Saving Logic ---
    const saveHistory = async () => {
      try {
        const userStr = localStorage.getItem("user");
        if (!userStr) return;
        const user = JSON.parse(userStr);

        // Extract episode index from URL or props
        // We need 0-based index. url is /watch/:id/:epNumber
        const currentPath = window.location.pathname;
        const parts = currentPath.split("/");
        const epNum = parseInt(parts[parts.length - 1]);
        const epIdx = isNaN(epNum) ? 0 : epNum - 1;

        if (!video.dataset.bookId || !user.id) return;

        const apiUrl = "/api/history";

        const res = await fetch(apiUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            userId: parseInt(user.id), // Ensure INT for backend
            bookId: video.dataset.bookId,
            episodeIdx: epIdx,
          }),
        });

        const json = await res.json();
        if (res.ok && json.status === "success") {
          console.log(
            `History saved: Episode ${epIdx + 1} (Debug Index: ${epIdx})`
          );
          localStorage.setItem("last_watch_update", Date.now().toString());
        } else {
          console.error("Server failed to save history:", json);
        }
      } catch (err) {
        console.error("Failed to save history:", err);
      }
    };

    // Save on initial play
    video.addEventListener(
      "play",
      () => {
        saveHistory();
      },
      { once: true }
    );

    // Save periodically (e.g., every 30 seconds)
    let lastSave = 0;
    video.addEventListener("timeupdate", () => {
      const now = Date.now();
      if (now - lastSave > 30000) {
        saveHistory();
        lastSave = now;
      }
    });

    // --- Core Video Logic ---

    // Mute State & Slider Sync
    function updateVolumeUI() {
      if (video.muted || video.volume === 0) {
        iconMuted?.classList.remove("hidden");
        iconUnmuted?.classList.add("hidden");
        if (volumeSlider) volumeSlider.value = "0";
      } else {
        iconMuted?.classList.add("hidden");
        iconUnmuted?.classList.remove("hidden");
        if (volumeSlider) volumeSlider.value = video.volume.toString();
      }
    }

    // Initial Sync
    updateVolumeUI();

    // Play/Pause Interactions
    // Play/Pause Interactons (Moved to robust handler below)
    // Duplicate removed

    // Mute Toggle
    if (muteBtn) {
      muteBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        // If muted, unmute and restore volume (default 1 if 0)
        if (video.muted) {
          video.muted = false;
          if (video.volume === 0) video.volume = 1;
        } else {
          // Toggle mute
          video.muted = !video.muted;
        }
        updateVolumeUI();
      });
    }

    // Volume Slider Change

    // --- Progress Bar Seeking Logic ---
    if (progressContainer && video) {
      let isScrubbing = false;

      const handleSeek = (e: MouseEvent | TouchEvent) => {
        // e.stopPropagation(); // Stop bubbling to prevent play/pause toggle if necessary
        const rect = progressContainer.getBoundingClientRect();
        let clientX = 0;

        if (e.type.startsWith("touch")) {
          clientX = (e as TouchEvent).touches[0].clientX;
        } else {
          clientX = (e as MouseEvent).clientX;
        }

        const width = rect.width;
        const offsetX = clientX - rect.left;
        const percentage = Math.max(0, Math.min(1, offsetX / width));

        // Update UI immediately for smoothness
        if (progressBar) progressBar.style.width = `${percentage * 100}%`;

        // Update video time
        if (video.duration) {
          video.currentTime = percentage * video.duration;
        }
      };

      // Click
      progressContainer.addEventListener("click", handleSeek);

      // Drag (Mouse)
      progressContainer.addEventListener("mousedown", (e) => {
        isScrubbing = true;
        handleSeek(e); // Seek on initial click too
      });
      document.addEventListener("mousemove", (e) => {
        if (isScrubbing) handleSeek(e);
      });
      document.addEventListener("mouseup", () => {
        isScrubbing = false;
      });

      // Drag (Touch) - CRITICAL for Mobile
      progressContainer.addEventListener(
        "touchstart",
        (e) => {
          isScrubbing = true;
          // e.preventDefault(); // Prevent scroll while scrubbing
          handleSeek(e);
        },
        { passive: false }
      );

      progressContainer.addEventListener(
        "touchmove",
        (e) => {
          if (isScrubbing) {
            e.preventDefault(); // Stop page scrolling
            // e.stopPropagation(); // Stop conflicting with container gestures
            handleSeek(e);
          }
        },
        { passive: false }
      );

      progressContainer.addEventListener("touchend", (e) => {
        isScrubbing = false;
        // Optionally Play video if it was paused? Nah.
      });
    }

    // Volume Slider Change
    if (volumeSlider) {
      volumeSlider.addEventListener("input", (e) => {
        e.stopPropagation();
        const val = parseFloat(volumeSlider.value);
        video.volume = val;
        video.muted = val === 0;
        updateVolumeUI();
      });

      // Prevent container click from closing/pausing if needed
      volumeSlider.addEventListener("click", (e) => e.stopPropagation());
    }

    // --- Controls Visibility (Smart Auto-Hide) ---
    let lastInteraction = Date.now();
    let controlsCheckInterval: any = null; // To check hide even if video paused? User wants permanent if paused usually.

    function pokeInteraction() {
      lastInteraction = Date.now();
      updateControlsVisibility();
    }

    // Global interaction listener for the container to keep UI awake
    if (container) {
      container.addEventListener("mousemove", pokeInteraction);
      container.addEventListener("touchstart", pokeInteraction, {
        passive: true,
      });
      container.addEventListener("click", pokeInteraction);
    }

    function updateControlsVisibility() {
      const now = Date.now();
      // Hide if:
      // 1. Video is PLAYING
      // 2. Time since last interaction > 4000ms (4 seconds)
      const shouldHide = !video.paused && now - lastInteraction > 4000;

      const toggle = (el: HTMLElement | null) => {
        if (!el) return;
        if (!shouldHide) {
          el.classList.remove("opacity-0", "pointer-events-none");
        } else {
          el.classList.add("opacity-0", "pointer-events-none");
        }
      };

      toggle(bottomControls);
      toggle(topLeftControls);
      toggle(document.getElementById("top-right-controls"));
    }

    // Loop to check visibility frequently (so it hides even if mouse doesn't move)
    setInterval(updateControlsVisibility, 1000);

    video.addEventListener("play", updateControlsVisibility);
    video.addEventListener("pause", updateControlsVisibility);
    // video.addEventListener("timeupdate") is redundant for UI hiding if we use setInterval,
    // but useful for progress bar. Keeping the existing listener for progress bar is fine.

    video.addEventListener("timeupdate", () => {
      if (
        progressBar &&
        Number.isFinite(video.duration) &&
        video.duration > 0
      ) {
        const percent = (video.currentTime / video.duration) * 100;
        progressBar.style.width = `${percent}%`;
      }
    });

    video.addEventListener("volumechange", updateVolumeUI); // Listen for external volume changes

    // Auto-Play Next Episode (SPA)
    video.addEventListener("ended", () => {
      const nextUrl = video.dataset.nextUrl;
      const autoplayPref = localStorage.getItem("pref_autoplay") !== "false";

      if (autoplayPref && nextUrl && nextUrl !== window.location.pathname) {
        loadEpisode(nextUrl);
      }
    });

    // --- Play/Pause Toggle with "Tap to Show" Logic ---
    if (playOverlay) {
      const handleOverlayTap = (e: Event) => {
        // Prevent default only for touch to avoid ghost clicks,
        // but we need to be careful not to block scrolling if it was a scroll gesture.
        // Simple tap usually doesn't involve scroll.
        if (e.type === "touchstart") e.preventDefault();

        const now = Date.now();
        const areControlsHidden =
          bottomControls?.classList.contains("opacity-0");

        // Logic:
        // 1. If Controls are HIDDEN -> Show them (Poke interaction).
        // 2. If Controls are VISIBLE -> Toggle Play/Pause.

        // Note: We check if they were hidden *before* pokeInteraction updates the state.

        if (areControlsHidden) {
          // Just wake up UI
          pokeInteraction();
          // Maybe show a quick "Paused" or "Play" icon animation?
          // For now, just showing controls is enough feedback.
        } else {
          // Controls already visible, so User intends to Play/Pause
          pokeInteraction(); // Keep them awake
          if (video.paused) {
            video.play().catch((e) => console.error(e));
            if (playIcon) playIcon.style.opacity = "0";
          } else {
            video.pause();
            if (playIcon) playIcon.style.opacity = "1";
          }
        }
      };

      playOverlay.addEventListener("click", handleOverlayTap);
      playOverlay.addEventListener("touchstart", handleOverlayTap, {
        passive: false,
      });
    }

    // --- FULLSCREEN LOGIC ---
    const fullscreenBtn = document.getElementById("fullscreen-btn");
    const iconMaximize = document.getElementById("icon-maximize");
    const iconMinimize = document.getElementById("icon-minimize");

    function toggleFullscreen() {
      const isFullscreen =
        document.fullscreenElement ||
        (document as any).webkitFullscreenElement ||
        (video as any).webkitDisplayingFullscreen;

      if (!isFullscreen) {
        // ENTER
        if (container && container.requestFullscreen) {
          container.requestFullscreen();
        } else if (container && (container as any).webkitRequestFullscreen) {
          (container as any).webkitRequestFullscreen();
        } else if (video && (video as any).webkitEnterFullscreen) {
          // iOS Fallback -> Target VIDEO directly
          (video as any).webkitEnterFullscreen();
        }
      } else {
        // EXIT
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if ((document as any).webkitExitFullscreen) {
          (document as any).webkitExitFullscreen();
        } else if ((video as any).webkitExitFullscreen) {
          (video as any).webkitExitFullscreen();
        }
      }
    }

    if (fullscreenBtn) {
      fullscreenBtn.addEventListener("click", toggleFullscreen);
    }

    // Listen for change
    document.addEventListener("fullscreenchange", updateFullscreenUI);
    document.addEventListener("webkitfullscreenchange", updateFullscreenUI);

    // Listen for iOS-specific fullscreen change on video element
    video.addEventListener("webkitbeginfullscreen", () => {
      // iOS native player took over. UI might not matter but let's update state for consistency
      iconMaximize?.classList.add("hidden");
      iconMinimize?.classList.remove("hidden");
    });
    video.addEventListener("webkitendfullscreen", () => {
      iconMaximize?.classList.remove("hidden");
      iconMinimize?.classList.add("hidden");
    });

    // Reattach Click Listener closer to elements if delegation fails?
    // Let's keep document delegation but make sure it halts immediate propagation.
    const handleSpaClick = (e: Event) => {
      const target = (e.target as HTMLElement).closest("a");
      if (!target) return;

      const href = target.getAttribute("href");
      if (!href || !href.startsWith("/watch/")) return;

      // Check if it's Next or Prev button in the player
      if (
        target.closest("#bottom-controls") ||
        target.closest("#top-left-controls")
      ) {
        e.preventDefault();
        e.stopPropagation();
        loadEpisode(href);
      }
    };

    // Use 'click' on document
    document.addEventListener("click", handleSpaClick, true); // Use Capture phase to ensure we get it first

    function updateFullscreenUI() {
      const isFullscreen =
        document.fullscreenElement || (document as any).webkitFullscreenElement;

      if (isFullscreen) {
        iconMaximize?.classList.add("hidden");
        iconMinimize?.classList.remove("hidden");
        container?.classList.remove("aspect-[9/16]", "max-w-full");
        container?.classList.add("w-screen", "h-screen");
      } else {
        iconMaximize?.classList.remove("hidden");
        iconMinimize?.classList.add("hidden");
        container?.classList.add("aspect-[9/16]", "max-w-full");
        container?.classList.remove("w-screen", "h-screen");
      }
    }

    // --- My List Logic (Hybrid: API + LocalStorage) ---
    const myListBtn = document.getElementById("mylist-btn");
    const iconAdd = document.getElementById("icon-add");
    const iconCheck = document.getElementById("icon-check");
    const myListText = document.getElementById("mylist-text");

    // Book ID & Data
    // Use a fallback to ensure we don't error out
    const bookId = video.dataset.bookId || "unknown_book";
    const dramaTitle = video.dataset.dramaTitle || "Unknown Title";
    const totalEpisodes = video.dataset.totalEpisodes || "?";
    const coverUrl = video.dataset.coverUrl || "";

    // User Check
    const userStr = localStorage.getItem("user");
    let user = null;
    try {
      if (userStr) user = JSON.parse(userStr);
    } catch (e) {}

    function updateMyListUI(isSaved: boolean) {
      if (isSaved) {
        iconAdd?.classList.add("hidden");
        iconCheck?.classList.remove("hidden");
        if (myListText) myListText.textContent = "Saved";
        myListBtn?.classList.add("text-red-500");
      } else {
        iconAdd?.classList.remove("hidden");
        iconCheck?.classList.add("hidden");
        if (myListText) myListText.textContent = "My List";
        myListBtn?.classList.remove("text-red-500");
      }
    }

    if (myListBtn) {
      const STORAGE_KEY = "drama_mylist";

      const checkStatus = async () => {
        if (user && user.id) {
          // API Check
          try {
            const res = await fetch(
              `/api/mylist/check/${bookId}?userId=${user.id}`
            );
            const json = await res.json();
            updateMyListUI(!!json.exists);
          } catch (e) {
            console.error("MyList check failed", e);
          }
        } else {
          // LocalStorage Check
          const savedList = JSON.parse(
            localStorage.getItem(STORAGE_KEY) || "[]"
          );
          const isSaved = savedList.some((d: any) => d.id === bookId);
          updateMyListUI(isSaved);
        }
      };

      // Broadcast Channel for Sync
      const syncChannel = new BroadcastChannel("dramaplay_sync");

      checkStatus();

      myListBtn.addEventListener("click", async (e) => {
        e.stopPropagation();

        const isAdded = myListBtn.classList.contains("text-red-500");

        if (user && user.id) {
          // API Action
          if (isAdded) {
            // Remove
            try {
              const res = await fetch(
                `/api/mylist/${bookId}?userId=${user.id}`,
                { method: "DELETE" }
              );
              if (res.ok) {
                updateMyListUI(false);
                showToast("Removed from My List");
                syncChannel.postMessage({
                  type: "MYLIST_UPDATE",
                  bookId,
                  status: false,
                });
              }
            } catch (e) {
              showToast("Error removing", true);
            }
          } else {
            // Add
            try {
              const res = await fetch(`/api/mylist`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ userId: user.id, bookId }),
              });
              if (res.ok) {
                updateMyListUI(true);
                showToast("Added to My List");
                syncChannel.postMessage({
                  type: "MYLIST_UPDATE",
                  bookId,
                  status: true,
                });
              }
            } catch (e) {
              showToast("Error adding", true);
            }
          }
        } else {
          // Guest Action (LocalStorage)
          const currentList = JSON.parse(
            localStorage.getItem(STORAGE_KEY) || "[]"
          );
          const existingIndex = currentList.findIndex(
            (d: any) => d.id === bookId
          );

          if (existingIndex >= 0) {
            currentList.splice(existingIndex, 1);
            updateMyListUI(false);
            showToast("Removed from My List");
            syncChannel.postMessage({
              type: "MYLIST_UPDATE",
              bookId,
              status: false,
            });
          } else {
            currentList.push({
              id: bookId,
              title: dramaTitle,
              episodes: totalEpisodes,
              cover: coverUrl,
            });
            updateMyListUI(true);
            showToast("Added to My List");
            syncChannel.postMessage({
              type: "MYLIST_UPDATE",
              bookId,
              status: true,
            });
          }
          localStorage.setItem(STORAGE_KEY, JSON.stringify(currentList));
        }
      });
    }

    // --- Swipe Gestures ---
    let touchStartY = 0;
    if (container) {
      container.addEventListener(
        "touchstart",
        (e) => {
          touchStartY = e.changedTouches[0].screenY;
        },
        { passive: false }
      );

      container.addEventListener(
        "touchmove",
        (e) => {
          const target = e.target as HTMLElement;
          // Allow scrolling in comments list
          if (target.closest("#comments-list")) {
            e.stopPropagation();
            return;
          }
          e.preventDefault();
        },
        { passive: false }
      );

      container.addEventListener("touchend", (e) => {
        const touchEndY = e.changedTouches[0].screenY;
        const diffY = touchStartY - touchEndY;

        // Block swipe if comments open
        const commentsOpen =
          commentsSheet &&
          !commentsSheet.classList.contains("translate-y-full");
        if (commentsOpen) return;

        // Swipe Up -> Next Ep
        if (diffY > 30) {
          const nextUrl = video.dataset.nextUrl;
          if (nextUrl && nextUrl !== window.location.pathname) {
            console.log("Swipe Up Detected. Navigating to:", nextUrl);
            window.location.href = nextUrl;
          }
        }
        // Swipe Down -> Prev Ep
        else if (diffY < -30) {
          const prevUrl = video.dataset.prevUrl;
          if (prevUrl && prevUrl !== window.location.pathname) {
            console.log("Swipe Down Detected. Navigating to:", prevUrl);
            window.location.href = prevUrl;
          }
        }
      });
    }

    // --- Comment Feature (Real Backend Integration) ---
    function timeAgo(dateString: string) {
      if (!dateString) return "";
      const date = new Date(dateString);
      const now = new Date();
      const diff = now.getTime() - date.getTime();

      // Ensure no negative time due to clock skew
      if (diff < 0) return "Just now";

      const seconds = Math.floor(diff / 1000);

      if (seconds < 60) return "Just now";
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m ago`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}h ago`;
      const days = Math.floor(hours / 24);
      if (days < 7) return `${days}d ago`;
      if (days < 30) return `${Math.floor(days / 7)}w ago`;

      return date.toLocaleDateString();
    }

    async function loadComments() {
      if (!commentsList || !commentCount) return;

      // Loading State
      commentsList.innerHTML = `
            <div class="animate-pulse flex gap-4">
                <div class="w-10 h-10 bg-zinc-800 rounded-full"></div>
                <div class="flex-1 space-y-2">
                    <div class="h-4 bg-zinc-800 rounded w-1/4"></div>
                    <div class="h-4 bg-zinc-800 rounded w-3/4"></div>
                </div>
            </div>`;

      try {
        const res = await fetch(`/api/comments/${bookId}`);
        let comments = [];
        if (res.ok) {
          const json = await res.json();
          if (json.status === "success") {
            comments = json.data || [];
          }
        }

        commentCount.textContent = `(${comments.length})`;

        if (comments.length === 0) {
          commentsList.innerHTML = `<p class="text-zinc-500 text-sm text-center py-8">No comments yet. Be the first!</p>`;
          return;
        }

        // Get Current User
        const userStr = localStorage.getItem("user");
        let currentUserId = 0;
        if (userStr) {
          try {
            const u = JSON.parse(userStr);
            currentUserId = u.id || 0;
          } catch (e) {}
        }

        commentsList.innerHTML = comments
          .map((c: any, i: number) => {
            const avatarHtml = c.user.avatar
              ? `<img src="${c.user.avatar}" class="w-8 h-8 rounded-full object-cover shrink-0">`
              : `<div class="w-8 h-8 rounded-full bg-zinc-700 flex items-center justify-center text-xs font-bold text-white shrink-0">${c.user.name[0]}</div>`;

            // Check Ownership
            // Ensure we robustly check for ID.
            // Note: c.user_id comes from DB. currentUserId comes from localStorage.
            const isOwner =
              currentUserId &&
              (Number(c.user_id) === Number(currentUserId) ||
                Number(c.user?.id) === Number(currentUserId));

            const actionsHtml = isOwner
              ? `
                           <div class="relative ml-2">
                               <button class="menu-btn text-zinc-500 hover:text-white p-1 rounded-full transition-colors" data-index="${i}">
                                   <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                                      <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.75a.75.75 0 110-1.5.75.75 0 010 1.5zM12 12.75a.75.75 0 110-1.5.75.75 0 010 1.5zM12 18.75a.75.75 0 110-1.5.75.75 0 010 1.5z" />
                                   </svg>
                               </button>
                               <!-- Dropdown Menu -->
                               <div id="menu-dropdown-${i}" class="menu-dropdown hidden absolute right-0 top-8 w-32 bg-zinc-900 border border-zinc-700 rounded-xl shadow-[0_10px_40px_-10px_rgba(0,0,0,0.5)] z-20 overflow-hidden animate-in fade-in zoom-in-95 duration-150 origin-top-right ring-1 ring-white/5">
                                   <button class="edit-btn w-full text-left px-4 py-2.5 text-xs font-medium text-zinc-300 hover:bg-white/5 hover:text-white transition-colors flex items-center gap-2" data-index="${i}">
                                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-3.5 h-3.5"><path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L6.832 19.82a4.5 4.5 0 01-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 011.13-1.897L16.863 4.487zm0 0L19.5 7.125" /></svg>
                                      Edit
                                   </button>
                                   <div class="h-px bg-white/5"></div>
                                   <button class="delete-btn w-full text-left px-4 py-2.5 text-xs font-medium text-red-500 hover:bg-red-500/10 transition-colors flex items-center gap-2" data-index="${i}" data-id="${c.id}">
                                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-3.5 h-3.5"><path stroke-linecap="round" stroke-linejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0" /></svg>
                                      Delete
                                   </button>
                               </div>
                           </div>
                        `
              : "";

            return `
                    <div class="flex gap-3 animate-in fade-in slide-in-from-bottom-2 duration-300 comment-item" data-time="${c.created_at}">
                        ${avatarHtml}
                        <div class="flex-1 space-y-1 group">
                            <div class="flex items-baseline justify-between">
                                <div class="flex items-center gap-2">
                                    <span class="text-sm font-bold text-white">${c.user.name}</span>
                                    <span class="text-[10px] text-zinc-500 time-display">${timeAgo(c.created_at)}</span>
                                </div>
                                ${actionsHtml}
                            </div>
                            
                            <!-- Display Mode -->
                            <p class="text-sm text-zinc-300 leading-snug whitespace-pre-line" id="comment-text-${i}">${c.content}</p>
                            
                            <!-- Edit Mode -->
                            <form class="hidden flex-col gap-2 mt-2 edit-form" data-index="${i}" data-id="${c.id}" id="edit-form-${i}">
                                <textarea class="w-full bg-zinc-800 text-white text-sm rounded-lg p-2 focus:outline-none focus:ring-1 focus:ring-red-600 resize-none" rows="2">${c.content}</textarea>
                                <div class="flex justify-end gap-2">
                                    <button type="button" class="text-xs text-zinc-400 font-bold hover:text-white cancel-btn" data-index="${i}">CANCEL</button>
                                    <button type="submit" class="text-xs text-red-500 font-bold hover:text-red-400">SAVE</button>
                                </div>
                            </form>
                        </div>
                    </div>
                `;
          })
          .join("");
      } catch (err) {
        console.error("Error loading comments:", err);
        commentsList.innerHTML = `<p class="text-red-500 text-sm text-center">Failed to load comments.</p>`;
      }
    }

    // Live Update Timestamps
    setInterval(() => {
      if (
        !commentsSheet ||
        commentsSheet.classList.contains("translate-y-full")
      )
        return; // Only if open
      document.querySelectorAll(".comment-item").forEach((item) => {
        const timeStr = item.getAttribute("data-time");
        const display = item.querySelector(".time-display");
        if (timeStr && display) {
          const newTime = timeAgo(timeStr);
          if (display.textContent !== newTime) display.textContent = newTime;
        }
      });
    }, 5000);

    function openComments() {
      if (!commentsSheet || !commentsBackdrop) return;
      commentsSheet.classList.remove("translate-y-full");
      commentsBackdrop.classList.remove("opacity-0", "pointer-events-none");
      loadComments();
    }

    function closeComments() {
      if (!commentsSheet || !commentsBackdrop) return;
      commentsSheet.classList.add("translate-y-full");
      commentsBackdrop.classList.add("opacity-0", "pointer-events-none");
    }

    // Attach Listeners
    document.addEventListener("click", (e) => {
      const target = e.target as HTMLElement;

      // Open Button
      const openBtn = target.closest("#comment-btn");
      if (openBtn) {
        e.stopPropagation();
        openComments();
        return;
      }

      // Close Button
      const closeBtn = target.closest("#close-comments");
      if (closeBtn) {
        closeComments();
        return;
      }

      // Handle Bar
      const handle = target.closest("#comments-handle");
      if (handle) {
        closeComments();
        return;
      }
    });

    // --- Custom UI Helpers ---
    const toastEl = document.getElementById("custom-toast");
    const toastMsg = document.getElementById("toast-message");
    let toastTimeout: any;

    function showToast(msg: string, isError = false) {
      if (!toastEl || !toastMsg) return;
      toastMsg.textContent = msg;

      // Reset classes
      toastEl.className =
        "absolute top-20 left-1/2 -translate-x-1/2 z-[60] px-6 py-2.5 text-sm font-medium rounded-full shadow-2xl border transition-all duration-300 transform";

      if (isError) {
        toastEl.classList.add("bg-red-900/90", "border-red-700", "text-white");
      } else {
        toastEl.classList.add(
          "bg-zinc-800/90",
          "border-zinc-700",
          "text-white"
        );
      }

      // Show
      requestAnimationFrame(() => {
        toastEl.classList.remove(
          "opacity-0",
          "translate-y-[-10px]",
          "pointer-events-none"
        );
        toastEl.classList.add("opacity-100", "translate-y-0");
      });

      // Auto Hide
      if (toastTimeout) clearTimeout(toastTimeout);
      toastTimeout = setTimeout(() => {
        toastEl.classList.remove("opacity-100", "translate-y-0");
        toastEl.classList.add(
          "opacity-0",
          "translate-y-[-10px]",
          "pointer-events-none"
        );
      }, 3000);
    }

    // Modal Helpers
    function openDeleteModal(index: string, id: string) {
      if (!deleteModal) return;
      deleteModal.classList.remove("hidden");
      pendingDeleteIndex = parseInt(index);
      // Store the ID on the confirm button or in a var
      if (btnConfirmDelete) btnConfirmDelete.setAttribute("data-id", id);
    }

    function closeDeleteModal() {
      if (!deleteModal) return;
      deleteModal.classList.add("hidden");
      pendingDeleteIndex = -1;
    }

    // Modal Listeners
    if (btnCancelDelete) {
      btnCancelDelete.addEventListener("click", closeDeleteModal);
    }

    if (btnConfirmDelete) {
      btnConfirmDelete.addEventListener("click", () => {
        const id = btnConfirmDelete.getAttribute("data-id");
        if (id) {
          deleteComment(id);
        }
        closeDeleteModal();
      });
    }

    // --- Post Comment ---
    if (commentForm) {
      commentForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        const text = commentInput.value.trim();
        if (!text) return;

        // Check Auth
        const token = localStorage.getItem("token");
        const userStr = localStorage.getItem("user");

        if (!token || !userStr) {
          window.location.href = "/login";
          return;
        }

        let currentUser = null;
        try {
          currentUser = JSON.parse(userStr);
        } catch (e) {}
        const userId = currentUser ? currentUser.id : 0;

        const submitBtn = commentForm.querySelector(
          'button[type="submit"]'
        ) as HTMLButtonElement;
        const originalBtnContent = submitBtn.innerHTML;
        submitBtn.disabled = true;
        submitBtn.innerHTML = `<svg class="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`;

        try {
          const res = await fetch(`/api/comments`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: token,
            },
            body: JSON.stringify({
              book_id: bookId,
              user_id: userId,
              content: text,
            }),
          });

          const json = await res.json();

          if (res.ok && json.status === "success") {
            commentInput.value = "";
            showToast("Comment posted successfully");
            loadComments();
          } else {
            console.error("Failed to post:", json);
            showToast(json.message || "Failed to post comment", true);
          }
        } catch (err) {
          console.error("Error posting:", err);
          showToast("Error connection to server", true);
        } finally {
          submitBtn.disabled = false;
          submitBtn.innerHTML = originalBtnContent;
          // Keep sheet open
        }
      });
    }

    // --- Actions Delegation ---
    document.addEventListener("click", (e) => {
      const target = e.target as HTMLElement;

      // Backdrop
      if (target.id === "comments-backdrop") {
        closeComments();
      }

      // 1. Toggle Menu Dropdown
      const menuBtn = target.closest(".menu-btn");
      if (menuBtn) {
        e.stopPropagation();
        const index = menuBtn.getAttribute("data-index");
        const dropdown = document.getElementById(`menu-dropdown-${index}`);

        document.querySelectorAll(".menu-dropdown").forEach((d) => {
          if (d.id !== `menu-dropdown-${index}`) d.classList.add("hidden");
        });

        if (dropdown) dropdown.classList.toggle("hidden");
        return;
      }

      if (!target.closest(".menu-dropdown") && !target.closest(".menu-btn")) {
        document
          .querySelectorAll(".menu-dropdown")
          .forEach((d) => d.classList.add("hidden"));
      }

      // 2. Edit Button
      const editBtn = target.closest(".edit-btn");
      if (editBtn) {
        e.stopPropagation();
        const index = editBtn.getAttribute("data-index");
        const textP = document.getElementById(`comment-text-${index}`);
        const form = document.getElementById(`edit-form-${index}`);
        const dropdown = document.getElementById(`menu-dropdown-${index}`);

        if (textP && form && dropdown) {
          textP.classList.add("hidden");
          form.classList.remove("hidden");
          form.classList.add("flex");
          dropdown.classList.add("hidden");
        }
        return;
      }

      // 3. Delete Button -> OPEN MODAL
      const deleteBtn = target.closest(".delete-btn");
      if (deleteBtn) {
        e.stopPropagation();
        const index = deleteBtn.getAttribute("data-index");
        const commentId = deleteBtn.getAttribute("data-id");

        if (index && commentId) {
          // Close dropdown first
          const dropdown = document.getElementById(`menu-dropdown-${index}`);
          if (dropdown) dropdown.classList.add("hidden");

          openDeleteModal(index, commentId);
        }
        return;
      }

      // 4. Cancel Edit
      const cancelBtn = target.closest(".cancel-btn");
      if (cancelBtn) {
        e.stopPropagation();
        const index = cancelBtn.getAttribute("data-index");
        const textP = document.getElementById(`comment-text-${index}`);
        const form = document.getElementById(`edit-form-${index}`);

        if (textP && form) {
          textP.classList.remove("hidden");
          form.classList.add("hidden");
          form.classList.remove("flex");
        }
        return;
      }
    });

    // Handle Dynamic Form Submit for Edits
    document.addEventListener("submit", async (e) => {
      const target = e.target as HTMLElement;
      if (target.classList.contains("edit-form")) {
        e.preventDefault();
        const form = target as HTMLFormElement;
        const index = form.getAttribute("data-index");
        const commentId = form.getAttribute("data-id");
        const textarea = form.querySelector("textarea");
        const newContent = textarea ? textarea.value.trim() : "";

        if (!commentId || !newContent) return;

        // Show Loading?
        const saveBtn = form.querySelector("button[type='submit']");
        const originalText = saveBtn ? saveBtn.textContent : "SAVE";
        if (saveBtn) saveBtn.textContent = "SAVING...";

        try {
          const token = localStorage.getItem("token");
          const res = await fetch(`/api/comments/${commentId}`, {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
              Authorization: token || "",
            },
            body: JSON.stringify({ content: newContent }),
          });

          if (res.ok) {
            showToast("Comment updated");
            loadComments(); // Refresh to show update
          } else {
            showToast("Failed to update comment", true);
          }
        } catch (err) {
          console.error(err);
          showToast("Error updating comment", true);
        } finally {
          if (saveBtn) saveBtn.textContent = originalText;
        }
      }
    });

    async function deleteComment(id: string) {
      try {
        const token = localStorage.getItem("token");
        const res = await fetch(`/api/comments/${id}`, {
          method: "DELETE",
          headers: { Authorization: token || "" },
        });
        if (res.ok) {
          showToast("Comment deleted");
          loadComments();
        } else {
          showToast("Failed to delete comment", true);
        }
      } catch (err) {
        console.error(err);
        showToast("Error deleting comment", true);
      }
    }
    // --- SPA NAVIGATION LOGIC (PERSISTENT FULLSCREEN) ---
    // Extract BookID and EpIdx from a URL like /watch/:bookId/:epIdx
    function parseWatchUrl(url: string) {
      const match = url.match(/\/watch\/([^\/]+)\/(\d+)/);
      if (match) {
        return { bookId: match[1], epIdx: parseInt(match[2], 10) };
      }
      return null;
    }

    async function loadEpisode(targetUrl: string) {
      console.log("SPA Navigating to:", targetUrl);
      const data = parseWatchUrl(targetUrl);
      if (!data) {
        // Fallback for non-standard URLs
        window.location.href = targetUrl;
        return;
      }
      const { bookId, epIdx } = data;

      // 1. Show Loading State (Optional: Overlay spinner?)
      // For now, keep current video until new one loads, or show poster?
      // video.pause(); // Maybe don't pause to keep flow until ready?

      try {
        // 2. Fetch Stream Data
        // Backend expects 'index' (1-based)
        const res = await fetch(`/api/stream?bookId=${bookId}&index=${epIdx}`);
        if (!res.ok) throw new Error("Stream fetch failed");

        const json = await res.json();
        if (json.status !== "success" || !json.data?.chapter?.video) {
          throw new Error("Invalid stream data");
        }

        const videoData = json.data.chapter.video;
        const newSrc = videoData.mp4 || videoData.m3u8;

        if (!newSrc) throw new Error("No video source found");

        // 3. Update State
        const oldSrc = video.src;

        // Update URL (Push State) without reload
        history.pushState({}, "", targetUrl);

        // Update Video Source
        // HTMLVideoElement loads new source when src changes
        video.src = newSrc;
        video.load();
        video.play().catch((e) => console.error("Autoplay failed:", e));

        // 4. Update UI Text (Title)
        // Assume format "Drama Title - Ep X"
        // We have dramaTitle in dataset!
        const cleanTitle = video.dataset.dramaTitle || "Drama";
        const titleEl = document.querySelector("#bottom-controls h1");
        if (titleEl) {
          titleEl.textContent = `${cleanTitle} - Ep ${epIdx}`;
        }

        // 5. Update Next/Prev Buttons & Dataset
        const total = parseInt(video.dataset.totalEpisodes || "0", 10);

        // Next
        const nextBtn = document.getElementById(
          "next-btn"
        ) as HTMLAnchorElement;
        const nextIdx = epIdx + 1;
        if (nextIdx <= total) {
          const newNextUrl = `/watch/${bookId}/${nextIdx}`;
          video.dataset.nextUrl = newNextUrl;
          if (nextBtn) {
            nextBtn.href = newNextUrl;
            nextBtn.parentElement?.classList.remove("hidden"); // Ensure visible
            // Remove old listener effectively by logic below or cloned node?
            // Actually we use a delegated listener or just let the global click handler catch it.
            // We will use a global click handler for .spa-link logic.
          }
        } else {
          video.dataset.nextUrl = "";
          if (nextBtn) nextBtn.parentElement?.classList.add("hidden");
        }

        // Prev
        const prevBtn = document.querySelector(
          "a[href*='/watch/']"
        ) as HTMLAnchorElement; // Select prev button generically if no ID, or add ID generic
        // Actually the prev button in the template is: { prevUrl && ( <a href={prevUrl}...>Prev</a> ) }
        // It doesn't have an ID "prev-btn". Let's assume we can find it via DOM order or add ID in template.
        // For now, let's look at the parent div: #bottom-controls .flex.gap-2 a

        const navLinks = document.querySelectorAll(
          "#bottom-controls .flex.gap-2 a"
        );
        let prevEl = null;
        if (navLinks.length > 0) {
          // Usually Prev is first if both exist, or checking text content
          navLinks.forEach((el) => {
            if (el.textContent?.trim() === "Prev")
              prevEl = el as HTMLAnchorElement;
          });
        }

        const prevIdx = epIdx - 1;
        if (prevIdx > 0) {
          const newPrevUrl = `/watch/${bookId}/${prevIdx}`;
          video.dataset.prevUrl = newPrevUrl;

          if (prevEl) {
            (prevEl as HTMLAnchorElement).href = newPrevUrl;
            (prevEl as HTMLElement).classList.remove("hidden");
          } else {
            // If it was hidden/removed, we might need to recreate it?
            // For simplicity, persistent fullscreen usually implies Next is most important.
            // Ensuring Prev works is bonus. If it was conditionally rendered off, it's missing from DOM.
            // We won't re-add it if missing to keep it simple, but we update if present.
          }
        } else {
          video.dataset.prevUrl = "";
          if (prevEl) (prevEl as HTMLElement).classList.add("hidden");
        }

        // 6. Save History (Logic re-reads URL, so it should work automatically via 'play' event or we trigger it)
        // The 'play' event will fire when video.play() is called.
        // But saveHistory parses URL. We updated window.location via pushState. So it should work!

        // 7. Reset Comments?
        // As analyzed, comments are per-book, so they persist.
        // But if we want to be safe or if comments were ep-specific?? No, they are per book.

        showToast(`Playing Episode ${epIdx}`);
      } catch (err) {
        console.error("SPA Nav Failed:", err);
        showToast("Error loading episode", true);
        // Fallback: Hard Navigate
        window.location.href = targetUrl;
      }
    }

    // Attach SPA Listener to Next/Prev
    // We delegate to document to handle button updates seamlessly
    document.addEventListener("click", (e) => {
      const target = (e.target as HTMLElement).closest("a");
      if (!target) return;

      const href = target.getAttribute("href");
      if (!href || !href.startsWith("/watch/")) return;

      // Check if it's Next or Prev button in the player
      if (target.closest("#bottom-controls")) {
        e.preventDefault();
        e.stopPropagation();
        loadEpisode(href);
      }
    });

    // Handle Browser Back/Forward (Popstate)
    // If user goes back in history, we should probably reload to ensure state consistency
    // OR implement loadEpisode for popstate.
    window.addEventListener("popstate", () => {
      loadEpisode(window.location.pathname);
    });
  }
</script>
