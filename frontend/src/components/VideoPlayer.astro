---
interface Props {
    videoUrl: string;
    coverUrl: string;
    title: string;
    nextUrl?: string;
    prevUrl?: string;
    id?: string; // Book ID for My List
    dramaTitle?: string; // Clean Title for My List
    totalEpisodes?: any; // Total Episodes for My List
}

const {
    videoUrl,
    coverUrl,
    title,
    nextUrl,
    prevUrl,
    id,
    dramaTitle,
    totalEpisodes,
} = Astro.props;
---

<div
    class="relative w-full h-[100dvh] bg-black overflow-hidden flex justify-center"
>
    <!-- Desktop Backdrop (Universal for pillarbox/letterbox areas) -->
    <div class="absolute inset-0 z-0">
        <img
            src={coverUrl}
            alt="Background"
            class="w-full h-full object-cover blur-3xl opacity-50 scale-110"
        />
        <div class="absolute inset-0 bg-black/60"></div>
    </div>

    <!-- Main Player Container -->
    <!-- 
        Universal Locked Ratio: 
        - Aspect Ratio: 9/16
        - Max Height: 100vh (Height driven)
        - Max Width: 100vw (Width driven)
        - Object Fit: Contain (Ensures header/footer doesn't cut if screen is weird)
        - Shadow/Ring for aesthetics on large screens
    -->
    <div
        id="video-container"
        class="relative z-10 w-auto h-full max-w-full aspect-[9/16] max-h-[100dvh] bg-black overflow-hidden flex items-center justify-center shadow-2xl"
    >
        <!-- Video Element -->
        <video
            id="main-video"
            src={videoUrl}
            poster={coverUrl}
            class="absolute top-0 left-0 w-full h-full object-cover"
            playsinline
            loop={false}
            autoplay
            webkit-playsinline
            data-next-url={nextUrl}
            data-prev-url={prevUrl}
            data-book-id={id}
            data-drama-title={dramaTitle}
            data-total-episodes={totalEpisodes}
            data-cover-url={coverUrl}></video>

        <!-- Overlay Gradient (Top) -->
        <div
            class="absolute top-0 left-0 w-full h-32 bg-gradient-to-b from-black/80 to-transparent pointer-events-none z-10"
        >
        </div>

        <!-- Top Controls -->
        <div
            id="top-left-controls"
            class="absolute top-4 left-4 z-20 transition-opacity duration-500"
        >
            <a
                href={`/detail/${id}`}
                class="p-3 bg-white/10 backdrop-blur-md rounded-full text-white active:scale-90 transition-transform block"
            >
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke-width="2"
                    stroke="currentColor"
                    class="w-6 h-6"
                >
                    <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        d="M15.75 19.5L8.25 12l7.5-7.5"></path>
                </svg>
            </a>
        </div>

        <!-- Volume Control Group (Top Right) -->
        <!-- Redesigned: Single Pill expanding upwards -->
        <div
            id="volume-control"
            class="absolute top-4 right-4 z-20 flex flex-col items-center bg-black/50 hover:bg-black/70 backdrop-blur-md rounded-full p-2 transition-all duration-300 group"
        >
            <!-- Vertical Slider Container (Collapses to 0 height) -->
            <div
                class="h-0 w-8 overflow-hidden group-hover:h-24 transition-all duration-300 ease-out flex items-center justify-center"
            >
                <input
                    type="range"
                    id="volume-slider"
                    min="0"
                    max="1"
                    step="0.1"
                    value="1"
                    class="w-20 h-1 bg-white/30 rounded-lg appearance-none cursor-pointer -rotate-90 origin-center accent-red-600 hover:accent-red-500"
                />
            </div>

            <!-- Mute Button (Icon only, transparency handled by parent) -->
            <button
                id="mute-btn"
                class="p-1 text-white active:scale-90 transition-transform"
            >
                <!-- Muted Icon -->
                <svg
                    id="icon-muted"
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke-width="1.5"
                    stroke="currentColor"
                    class="w-6 h-6 hidden"
                >
                    <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        d="M17.25 9.75L19.5 12m0 0l2.25 2.25M19.5 12l2.25-2.25M19.5 12l-2.25 2.25m-10.5-6l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75z"
                    ></path>
                </svg>
                <!-- Unmuted Icon -->
                <svg
                    id="icon-unmuted"
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke-width="1.5"
                    stroke="currentColor"
                    class="w-6 h-6"
                >
                    <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        d="M19.114 5.636a9 9 0 010 12.728M16.463 8.288a5.25 5.25 0 010 7.424M6.75 8.25l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75z"
                    ></path>
                </svg>
            </button>
        </div>

        <!-- Overlay Gradient (Bottom) -->
        <div
            class="absolute bottom-0 left-0 w-full h-64 bg-gradient-to-t from-black/90 via-black/40 to-transparent pointer-events-none z-10"
        >
        </div>

        <!-- Bottom Info & Controls -->
        <div
            id="bottom-controls"
            class="absolute bottom-0 left-0 w-full p-6 z-20 flex flex-col gap-4 transition-opacity duration-500"
        >
            <!-- Text Info -->
            <h1 class="text-xl font-bold text-white drop-shadow-md">{title}</h1>

            <!-- Progress Bar -->
            <div class="w-full h-1 bg-white/30 rounded-full overflow-hidden">
                <div id="progress-bar" class="h-full bg-red-600 w-0"></div>
            </div>

            <!-- Action Buttons -->
            <div class="flex items-center justify-between text-white">
                <div class="flex gap-4">
                    <!-- My List Toggle -->
                    <button
                        id="mylist-btn"
                        class="flex flex-col items-center gap-1 group"
                    >
                        <svg
                            id="icon-add"
                            xmlns="http://www.w3.org/2000/svg"
                            fill="none"
                            viewBox="0 0 24 24"
                            stroke-width="1.5"
                            stroke="currentColor"
                            class="w-8 h-8 group-active:scale-90 transition-transform"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                d="M17.593 3.322c1.1.128 1.907 1.077 1.907 2.185V21L12 17.25 4.5 21V5.507c0-1.108.806-2.057 1.907-2.185a48.507 48.507 0 0111.186 0z"
                            ></path>
                        </svg>
                        <svg
                            id="icon-check"
                            xmlns="http://www.w3.org/2000/svg"
                            viewBox="0 0 24 24"
                            fill="currentColor"
                            class="w-8 h-8 text-red-500 hidden group-active:scale-90 transition-transform"
                        >
                            <path
                                fill-rule="evenodd"
                                d="M6.32 2.577a49.255 49.255 0 0111.36 0c1.497.174 2.57 1.46 2.57 2.93V21a.75.75 0 01-1.085.67L12 18.089l-7.165 3.583A.75.75 0 013.75 21V5.507c0-1.47 1.073-2.756 2.57-2.93z"
                                clip-rule="evenodd"></path>
                        </svg>
                        <span id="mylist-text" class="text-xs">My List</span>
                    </button>
                    <button
                        id="comment-btn"
                        class="flex flex-col items-center gap-1 active:scale-95 transition-transform"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            viewBox="0 0 24 24"
                            fill="currentColor"
                            class="w-8 h-8"
                        >
                            <path
                                fill-rule="evenodd"
                                d="M4.804 21.644A6.707 6.707 0 006 21.75a6.721 6.721 0 003.583-1.029c.774.182 1.584.279 2.417.279 5.322 0 9.75-3.97 9.75-9 0-5.03-4.428-9-9.75-9s-9.75 3.97-9.75 9c0 2.409 1.025 4.608 2.75 6.257a1.606 1.606 0 01.32.964v2.423z"
                                clip-rule="evenodd"></path>
                        </svg>
                        <span class="text-xs">Comment</span>
                    </button>
                </div>

                <!-- Navigation -->
                <div class="flex gap-2">
                    {
                        prevUrl && (
                            <a
                                href={prevUrl}
                                class="px-4 py-2 bg-white/20 rounded-full backdrop-blur-sm text-sm font-semibold"
                            >
                                Prev
                            </a>
                        )
                    }
                    {
                        nextUrl && (
                            <a
                                id="next-btn"
                                href={nextUrl}
                                class="px-4 py-2 bg-red-600 rounded-full text-white text-sm font-semibold shadow-red-900/50 shadow-lg"
                            >
                                Next Ep
                            </a>
                        )
                    }
                </div>
            </div>
        </div>

        <!-- Play/Pause Overlay Hitbox -->
        <div id="play-overlay" class="absolute inset-0 z-0"></div>
        <div
            id="play-icon"
            class="absolute inset-0 z-30 flex items-center justify-center pointer-events-none opacity-0 transition-opacity"
        >
            <svg
                xmlns="http://www.w3.org/2000/svg"
                fill="white"
                viewBox="0 0 24 24"
                class="w-20 h-20 drop-shadow-lg"
            >
                <path d="M8 5v14l11-7z"></path>
            </svg>
        </div>

        <!-- Comments Bottom Sheet -->
        <div
            id="comments-sheet"
            class="absolute inset-x-0 bottom-0 z-50 bg-[#1a1a1a] rounded-t-2xl transform translate-y-full transition-transform duration-300 ease-out h-[70vh] flex flex-col shadow-2xl border-t border-white/10"
        >
            <!-- Handle Bar -->
            <div
                class="w-full flex justify-center pt-3 pb-1"
                id="comments-handle"
            >
                <div class="w-12 h-1.5 bg-zinc-700 rounded-full"></div>
            </div>

            <!-- Header -->
            <div
                class="px-4 py-2 flex items-center justify-between border-b border-white/5"
            >
                <h3 class="text-white font-bold text-lg">
                    Comments <span
                        id="comment-count"
                        class="text-zinc-500 text-sm font-normal">(0)</span
                    >
                </h3>
                <button
                    id="close-comments"
                    class="p-2 text-zinc-400 hover:text-white"
                >
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        fill="none"
                        viewBox="0 0 24 24"
                        stroke-width="2"
                        stroke="currentColor"
                        class="w-6 h-6"
                    >
                        <path
                            stroke-linecap="round"
                            stroke-linejoin="round"
                            d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>

            <!-- Comments List -->
            <div
                id="comments-list"
                class="flex-1 overflow-y-auto p-4 space-y-4 no-scrollbar"
            >
                <!-- Dynamic Content -->
            </div>

            <!-- Input Area -->
            <div class="p-4 border-t border-white/10 bg-[#1a1a1a] pb-safe">
                <form id="comment-form" class="flex gap-3">
                    <input
                        type="text"
                        id="comment-input"
                        placeholder="Add a comment..."
                        class="flex-1 bg-zinc-800 text-white rounded-full px-4 py-2.5 text-sm focus:outline-none focus:ring-1 focus:ring-red-600 border border-transparent placeholder-zinc-500"
                    />
                    <button
                        type="submit"
                        class="bg-red-600 text-white p-2.5 rounded-full hover:bg-red-700 active:scale-95 transition-transform disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            viewBox="0 0 24 24"
                            fill="currentColor"
                            class="w-5 h-5"
                        >
                            <path
                                d="M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.519 60.519 0 0018.445-8.986.75.75 0 000-1.218A60.517 60.517 0 003.478 2.405z"
                            ></path>
                        </svg>
                    </button>
                </form>
            </div>
        </div>
        <!-- Comments Overlay Backdrop -->
        <div
            id="comments-backdrop"
            class="absolute inset-0 z-40 bg-black/50 opacity-0 pointer-events-none transition-opacity duration-300 backdrop-blur-sm"
        >
        </div>
    </div>
</div>

<style>
    .pb-safe {
        padding-bottom: max(env(safe-area-inset-bottom), 16px);
    }
</style>

<script>
    const video = document.getElementById("main-video") as HTMLVideoElement;
    const container = document.getElementById("video-container");
    const playOverlay = document.getElementById("play-overlay");
    const playIcon = document.getElementById("play-icon");
    const progressBar = document.getElementById("progress-bar");
    const muteBtn = document.getElementById("mute-btn");
    const volumeSlider = document.getElementById(
        "volume-slider",
    ) as HTMLInputElement;
    const volumeControl = document.getElementById("volume-control"); // Wrapper for auto-hide
    const iconMuted = document.getElementById("icon-muted");
    const iconUnmuted = document.getElementById("icon-unmuted");
    const bottomControls = document.getElementById("bottom-controls");
    const topLeftControls = document.getElementById("top-left-controls");

    // Comment Elements
    const commentsSheet = document.getElementById("comments-sheet");
    const commentsBackdrop = document.getElementById("comments-backdrop");
    const commentCount = document.getElementById("comment-count");
    const commentsList = document.getElementById("comments-list");
    const commentForm = document.getElementById("comment-form");
    const commentInput = document.getElementById(
        "comment-input",
    ) as HTMLInputElement;

    console.log("Video Player Script Initialized");

    if (video) {
        // --- History Saving Logic ---
        const saveHistory = async () => {
            try {
                const userStr = localStorage.getItem("user");
                if (!userStr) return;
                const user = JSON.parse(userStr);

                // Extract episode index from URL or props
                // We need 0-based index. url is /watch/:id/:epNumber
                const currentPath = window.location.pathname;
                const parts = currentPath.split("/");
                const epNum = parseInt(parts[parts.length - 1]);
                const epIdx = isNaN(epNum) ? 0 : epNum - 1;

                if (!video.dataset.bookId || !user.id) return;

                const apiUrl = "/api/history";

                const res = await fetch(apiUrl, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        userId: parseInt(user.id), // Ensure INT for backend
                        bookId: video.dataset.bookId,
                        episodeIdx: epIdx,
                    }),
                });

                const json = await res.json();
                if (res.ok && json.status === "success") {
                    console.log(
                        `History saved: Episode ${epIdx + 1} (Debug Index: ${epIdx})`,
                    );
                    localStorage.setItem(
                        "last_watch_update",
                        Date.now().toString(),
                    );
                } else {
                    console.error("Server failed to save history:", json);
                }
            } catch (err) {
                console.error("Failed to save history:", err);
            }
        };

        // Save on initial play
        video.addEventListener(
            "play",
            () => {
                saveHistory();
            },
            { once: true },
        );

        // Save periodically (e.g., every 30 seconds)
        let lastSave = 0;
        video.addEventListener("timeupdate", () => {
            const now = Date.now();
            if (now - lastSave > 30000) {
                saveHistory();
                lastSave = now;
            }
        });

        // --- Core Video Logic ---

        // Mute State & Slider Sync
        function updateVolumeUI() {
            if (video.muted || video.volume === 0) {
                iconMuted?.classList.remove("hidden");
                iconUnmuted?.classList.add("hidden");
                if (volumeSlider) volumeSlider.value = "0";
            } else {
                iconMuted?.classList.add("hidden");
                iconUnmuted?.classList.remove("hidden");
                if (volumeSlider) volumeSlider.value = video.volume.toString();
            }
        }

        // Initial Sync
        updateVolumeUI();

        // Play/Pause Interactions
        if (playOverlay) {
            playOverlay.addEventListener("click", () => {
                if (video.paused) {
                    video.play();
                    playIcon!.style.opacity = "0";
                } else {
                    video.pause();
                    playIcon!.style.opacity = "1";
                }
            });
        }

        // Mute Toggle
        if (muteBtn) {
            muteBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                // If muted, unmute and restore volume (default 1 if 0)
                if (video.muted) {
                    video.muted = false;
                    if (video.volume === 0) video.volume = 1;
                } else {
                    // Toggle mute
                    video.muted = !video.muted;
                }
                updateVolumeUI();
            });
        }

        // Volume Slider Change
        if (volumeSlider) {
            volumeSlider.addEventListener("input", (e) => {
                e.stopPropagation();
                const val = parseFloat(volumeSlider.value);
                video.volume = val;
                video.muted = val === 0;
                updateVolumeUI();
            });

            // Prevent container click from closing/pausing if needed
            volumeSlider.addEventListener("click", (e) => e.stopPropagation());
        }

        // Controls Visibility Auto-Hide
        function updateControlsVisibility() {
            // Hide if playing AND time > 5s
            const shouldHide = !video.paused && video.currentTime > 5;

            // Helper to toggle classes safely
            const toggle = (el: HTMLElement | null) => {
                if (!el) return;

                // If interacting with volume, don't auto-hide immediately (optional enhancement, but keep simple for now)
                // Actually, if user hovers volume-control, we might want to keep it visible.
                // CSS hover handles the slider visibility, but opacity-0 on parent hides everything.

                if (!shouldHide) {
                    el.classList.remove("opacity-0", "pointer-events-none");
                } else {
                    el.classList.add("opacity-0", "pointer-events-none");
                }
            };

            toggle(bottomControls);
            toggle(topLeftControls);
            toggle(volumeControl); // Updated to toggle the wrapper group
        }

        video.addEventListener("timeupdate", () => {
            if (progressBar) {
                const percent = (video.currentTime / video.duration) * 100;
                progressBar.style.width = `${percent}%`;
            }
            updateControlsVisibility();
        });

        video.addEventListener("play", updateControlsVisibility);
        video.addEventListener("pause", updateControlsVisibility);
        video.addEventListener("volumechange", updateVolumeUI); // Listen for external volume changes

        // Auto-Play Next Episode
        video.addEventListener("ended", () => {
            const nextUrl = video.dataset.nextUrl;
            if (nextUrl && nextUrl !== window.location.pathname) {
                console.log("Video Ended. Auto-playing next episode:", nextUrl);
                // Optional: Show a "Next Episode starting..." toast here if desired
                window.location.href = nextUrl;
            }
        });

        // Tap container (not overlay) to show controls?
        // Actually playOverlay covers everything, so its click handler handles Play/Pause.
        // We might want a separate "Show Controls" tap if we don't want to pause?
        // For now, let's stick to current behavior: Click = Toggle Play = Show Controls (if paused).

        // --- My List Logic ---
        const myListBtn = document.getElementById("mylist-btn");
        const iconAdd = document.getElementById("icon-add");
        const iconCheck = document.getElementById("icon-check");
        const myListText = document.getElementById("mylist-text");

        // Book ID & Data
        // Use a fallback to ensure we don't error out
        const bookId = video.dataset.bookId || "unknown_book";
        const dramaTitle = video.dataset.dramaTitle || "Unknown Title";
        const totalEpisodes = video.dataset.totalEpisodes || "?";
        const coverUrl = video.dataset.coverUrl || "";

        function updateMyListUI(isSaved: boolean) {
            if (isSaved) {
                iconAdd?.classList.add("hidden");
                iconCheck?.classList.remove("hidden");
                if (myListText) myListText.textContent = "Saved";
                myListBtn?.classList.add("text-red-500");
            } else {
                iconAdd?.classList.remove("hidden");
                iconCheck?.classList.add("hidden");
                if (myListText) myListText.textContent = "My List";
                myListBtn?.classList.remove("text-red-500");
            }
        }

        if (myListBtn) {
            const savedList = JSON.parse(
                localStorage.getItem("drama_mylist") || "[]",
            );
            const isSaved = savedList.some((d: any) => d.id === bookId);
            updateMyListUI(isSaved);

            myListBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                const currentList = JSON.parse(
                    localStorage.getItem("drama_mylist") || "[]",
                );
                const existingIndex = currentList.findIndex(
                    (d: any) => d.id === bookId,
                );

                if (existingIndex >= 0) {
                    currentList.splice(existingIndex, 1);
                    updateMyListUI(false);
                } else {
                    currentList.push({
                        id: bookId,
                        title: dramaTitle,
                        episodes: totalEpisodes,
                        cover: coverUrl,
                    });
                    updateMyListUI(true);
                }
                localStorage.setItem(
                    "drama_mylist",
                    JSON.stringify(currentList),
                );
            });
        }

        // --- Swipe Gestures ---
        let touchStartY = 0;
        if (container) {
            container.addEventListener(
                "touchstart",
                (e) => {
                    touchStartY = e.changedTouches[0].screenY;
                },
                { passive: false },
            );

            container.addEventListener(
                "touchmove",
                (e) => {
                    const target = e.target as HTMLElement;
                    // Allow scrolling in comments list
                    if (target.closest("#comments-list")) {
                        e.stopPropagation();
                        return;
                    }
                    e.preventDefault();
                },
                { passive: false },
            );

            container.addEventListener("touchend", (e) => {
                const touchEndY = e.changedTouches[0].screenY;
                const diffY = touchStartY - touchEndY;

                // Block swipe if comments open
                const commentsOpen =
                    commentsSheet &&
                    !commentsSheet.classList.contains("translate-y-full");
                if (commentsOpen) return;

                // Swipe Up -> Next Ep
                if (diffY > 30) {
                    const nextUrl = video.dataset.nextUrl;
                    if (nextUrl && nextUrl !== window.location.pathname) {
                        console.log(
                            "Swipe Up Detected. Navigating to:",
                            nextUrl,
                        );
                        window.location.href = nextUrl;
                    }
                }
                // Swipe Down -> Prev Ep
                else if (diffY < -30) {
                    const prevUrl = video.dataset.prevUrl;
                    if (prevUrl && prevUrl !== window.location.pathname) {
                        console.log(
                            "Swipe Down Detected. Navigating to:",
                            prevUrl,
                        );
                        window.location.href = prevUrl;
                    }
                }
            });
        }

        // --- Comment Feature (Refactored) ---
        const dummyComments = [
            {
                name: "Sarah J.",
                text: "Omg this episode!! ðŸ˜­ðŸ˜­",
                time: "2m ago",
            },
            {
                name: "DracoFan",
                text: "Why is he so handsome?",
                time: "5m ago",
            },
            {
                name: "KdramaAddict",
                text: "Waiting for next ep...",
                time: "10m ago",
            },
            { name: "User123", text: "Plot twist detected!", time: "1h ago" },
            {
                name: "Mina",
                text: "Please upload faster admin ðŸ™",
                time: "2h ago",
            },
        ];

        function loadComments() {
            if (!commentsList || !commentCount) return;
            try {
                const storageKey = `comments_${bookId}`;
                const userComments = JSON.parse(
                    localStorage.getItem(storageKey) || "[]",
                );
                const allComments = [...userComments, ...dummyComments];

                // Get current user for fallback/retroactive fix
                const userStr = localStorage.getItem("user");
                let currentUserPhoto = "";
                let currentUserName = "You";
                if (userStr) {
                    try {
                        const u = JSON.parse(userStr);
                        // Check valid keys
                        currentUserPhoto = u.avatar || u.photo_profile || "";
                        currentUserName = u.name || u.username || "You";
                    } catch (e) {}
                }

                commentCount.textContent = `(${allComments.length})`;
                commentsList.innerHTML = allComments
                    .map((c, i) => {
                        // Improved Owner Logic: Check Index OR Name match
                        const isOwner =
                            i < userComments.length ||
                            c.name === currentUserName ||
                            c.name === "You";

                        console.log(
                            `Comment ${i}: ${c.name}, Owner: ${isOwner} (User: ${currentUserName})`,
                        );

                        // Photo logic
                        const photoToUse =
                            c.photo ||
                            (c.name === currentUserName || c.name === "You"
                                ? currentUserPhoto
                                : "");

                        const avatarHtml = photoToUse
                            ? `<img src="${photoToUse}" class="w-8 h-8 rounded-full object-cover shrink-0">`
                            : `<div class="w-8 h-8 rounded-full bg-zinc-700 flex items-center justify-center text-xs font-bold text-white shrink-0">${c.name[0]}</div>`;

                        // Actions
                        const actionsHtml = isOwner
                            ? `
                           <div class="flex gap-3 ml-2">
                               <button class="text-zinc-500 hover:text-white transition-colors edit-btn" data-index="${i}">
                                   <!-- Pencil Icon -->
                                   <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4"><path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L6.832 19.82a4.5 4.5 0 01-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 011.13-1.897L16.863 4.487zm0 0L19.5 7.125" /></svg>
                               </button>
                               <button class="text-zinc-500 hover:text-red-500 transition-colors delete-btn" data-index="${i}">
                                   <!-- Trash Icon -->
                                   <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4"><path stroke-linecap="round" stroke-linejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0" /></svg>
                               </button>
                           </div>
                        `
                            : "";

                        return `
                    <div class="flex gap-3 animate-in fade-in slide-in-from-bottom-2 duration-300">
                        ${avatarHtml}
                        <div class="flex-1 space-y-1 group">
                            <div class="flex items-baseline justify-between">
                                <div class="flex items-center gap-2">
                                    <span class="text-sm font-bold text-white">${c.name} ${isOwner ? '<span class="text-green-500 text-[10px] ml-1">(YOU)</span>' : ""}</span>
                                    <span class="text-[10px] text-zinc-500">${c.time}</span>
                                </div>
                                ${actionsHtml}
                            </div>
                            
                            <!-- Display Mode -->
                            <p class="text-sm text-zinc-300 leading-snug" id="comment-text-${i}">${c.text}</p>
                            
                            <!-- Edit Mode -->
                            <form class="hidden flex-col gap-2 mt-2 edit-form" data-index="${i}" id="edit-form-${i}">
                                <textarea class="w-full bg-zinc-800 text-white text-sm rounded-lg p-2 focus:outline-none focus:ring-1 focus:ring-red-600 resize-none" rows="2">${c.text}</textarea>
                                <div class="flex justify-end gap-2">
                                    <button type="button" class="text-xs text-zinc-400 font-bold hover:text-white cancel-btn" data-index="${i}">CANCEL</button>
                                    <button type="submit" class="text-xs text-red-500 font-bold hover:text-red-400">SAVE</button>
                                </div>
                            </form>
                        </div>
                    </div>
                `;
                    })
                    .join("");
            } catch (err) {
                console.error("Error loading comments:", err);
            }
        }

        function openComments() {
            console.log("Opening Comments Sheet");
            if (!commentsSheet || !commentsBackdrop) {
                console.error("Comments elements not found!");
                return;
            }
            commentsSheet.classList.remove("translate-y-full");
            commentsBackdrop.classList.remove(
                "opacity-0",
                "pointer-events-none",
            );
            loadComments();
        }

        function closeComments() {
            if (!commentsSheet || !commentsBackdrop) return;
            commentsSheet.classList.add("translate-y-full");
            commentsBackdrop.classList.add("opacity-0", "pointer-events-none");
        }

        // Attach Listeners via Event Delegation for Robustness
        document.addEventListener("click", (e) => {
            const target = e.target as HTMLElement;

            // Open Button
            const openBtn = target.closest("#comment-btn");
            if (openBtn) {
                e.stopPropagation();
                openComments();
                return;
            }

            // Close Button
            const closeBtn = target.closest("#close-comments");
            if (closeBtn) {
                closeComments();
                return;
            }

            // Handle Bar (to close)
            const handle = target.closest("#comments-handle");
            if (handle) {
                closeComments();
                return;
            }

            // Check if clicked outside sheet (Backdrop)
            if (target.id === "comments-backdrop") {
                closeComments();
            }

            // --- Comment Actions (Delete / Edit / Cancel) ---

            // Delete
            const deleteBtn = target.closest(".delete-btn") as HTMLElement;
            if (deleteBtn) {
                const idx = parseInt(deleteBtn.dataset.index || "-1");
                if (idx > -1 && confirm("Delete this comment?")) {
                    const storageKey = `comments_${bookId}`;
                    const userComments = JSON.parse(
                        localStorage.getItem(storageKey) || "[]",
                    );
                    if (userComments[idx]) {
                        userComments.splice(idx, 1);
                        localStorage.setItem(
                            storageKey,
                            JSON.stringify(userComments),
                        );
                        loadComments();
                    }
                }
                return;
            }

            // Edit (Show Form)
            const editBtn = target.closest(".edit-btn") as HTMLElement;
            if (editBtn) {
                const idx = parseInt(editBtn.dataset.index || "-1");
                if (idx > -1) {
                    const textEl = document.getElementById(
                        `comment-text-${idx}`,
                    );
                    const formEl = document.getElementById(`edit-form-${idx}`);
                    if (textEl && formEl) {
                        textEl.classList.add("hidden");
                        formEl.classList.remove("hidden");
                        formEl.classList.add("flex");
                        // Focus textarea
                        const ta = formEl.querySelector("textarea");
                        if (ta) ta.focus();
                    }
                }
                return;
            }

            // Cancel Edit
            const cancelBtn = target.closest(".cancel-btn") as HTMLElement;
            if (cancelBtn) {
                const idx = parseInt(cancelBtn.dataset.index || "-1");
                if (idx > -1) {
                    const textEl = document.getElementById(
                        `comment-text-${idx}`,
                    );
                    const formEl = document.getElementById(`edit-form-${idx}`);
                    if (textEl && formEl) {
                        textEl.classList.remove("hidden");
                        formEl.classList.add("hidden");
                        formEl.classList.remove("flex");
                    }
                }
                return;
            }
        });

        // Event for Edit Form Submit (Dynamic)
        document.addEventListener("submit", (e) => {
            const target = e.target as HTMLElement;
            const form = target.closest(".edit-form") as HTMLFormElement;
            if (form) {
                e.preventDefault();
                const idx = parseInt(form.dataset.index || "-1");
                const ta = form.querySelector("textarea");
                const newText = ta ? ta.value.trim() : "";

                if (idx > -1 && newText) {
                    const storageKey = `comments_${bookId}`;
                    const userComments = JSON.parse(
                        localStorage.getItem(storageKey) || "[]",
                    );
                    if (userComments[idx]) {
                        userComments[idx].text = newText;
                        userComments[idx].time = "Edited just now"; // Optional: Update time
                        localStorage.setItem(
                            storageKey,
                            JSON.stringify(userComments),
                        );
                        loadComments();
                    }
                }
            }
        });

        // Form Submit
        if (commentForm) {
            commentForm.addEventListener("submit", (e) => {
                e.preventDefault();
                const text = commentInput.value.trim();
                if (!text) return;

                // Get User Data
                const userStr = localStorage.getItem("user");
                let userName = "You";
                let userPhoto = "";

                if (userStr) {
                    try {
                        const user = JSON.parse(userStr);
                        // Check multiple keys for robustness
                        userName = user.name || user.username || "You";
                        userPhoto = user.avatar || user.photo_profile || "";
                    } catch (e) {}
                }

                const newComment = {
                    name: userName,
                    photo: userPhoto,
                    text: text,
                    time: "Just now",
                };

                const storageKey = `comments_${bookId}`;
                const currentComments = JSON.parse(
                    localStorage.getItem(storageKey) || "[]",
                );
                currentComments.unshift(newComment);
                localStorage.setItem(
                    storageKey,
                    JSON.stringify(currentComments),
                );

                commentInput.value = "";
                loadComments();
                if (commentsList) commentsList.scrollTop = 0;
            });
        }
    }
</script>
